function [methodinfo,structs,enuminfo,ThunkLibName]=ps5000MFile_glnxa64
%PS5000MFILE_GLNXA64 Create structures to define interfaces found in 'ps5000Api'.

%This function was generated by loadlibrary.m parser version  on Tue May  2 15:29:28 2017
%perl options:'ps5000Api.i -outfile=ps5000MFile_glnxa64.m -thunkfile=ps5000_thunk_glnxa64.c -header=ps5000Api.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'ps5000_thunk_glnxa64');
% PICO_STATUS ps5000OpenUnit ( int16_t * handle ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='ps5000OpenUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000OpenUnitAsync ( int16_t * status ); 
fcns.thunkname{fcnNum}='uint32voidPtrThunk';fcns.name{fcnNum}='ps5000OpenUnitAsync'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000OpenUnitProgress ( int16_t * handle , int16_t * progressPercent , int16_t * complete ); 
fcns.thunkname{fcnNum}='uint32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ps5000OpenUnitProgress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetUnitInfo ( int16_t handle , char * string , int16_t stringLength , int16_t * requiredSize , PICO_INFO info ); 
fcns.thunkname{fcnNum}='uint32int16cstringint16voidPtruint32Thunk';fcns.name{fcnNum}='ps5000GetUnitInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000FlashLed ( int16_t handle , int16_t start ); 
fcns.thunkname{fcnNum}='uint32int16int16Thunk';fcns.name{fcnNum}='ps5000FlashLed'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000IsLedFlashing ( int16_t handle , int16_t * status ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps5000IsLedFlashing'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000CloseUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps5000CloseUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000MemorySegments ( int16_t handle , uint16_t nSegments , int32_t * nMaxSamples ); 
fcns.thunkname{fcnNum}='uint32int16uint16voidPtrThunk';fcns.name{fcnNum}='ps5000MemorySegments'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16', 'int32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetChannel ( int16_t handle , PS5000_CHANNEL channel , int16_t enabled , int16_t dc , PS5000_RANGE range ); 
fcns.thunkname{fcnNum}='uint32int16PS5000_CHANNELint16int16PS5000_RANGEThunk';fcns.name{fcnNum}='ps5000SetChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS5000Channel', 'int16', 'int16', 'enPS5000Range'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetTimebase ( int16_t handle , uint32_t timebase , int32_t noSamples , int32_t * timeIntervalNanoseconds , int16_t oversample , int32_t * maxSamples , uint16_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32int32voidPtrint16voidPtruint16Thunk';fcns.name{fcnNum}='ps5000GetTimebase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'int32', 'int32Ptr', 'int16', 'int32Ptr', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetTimebase2 ( int16_t handle , uint32_t timebase , int32_t noSamples , float * timeIntervalNanoseconds , int16_t oversample , int32_t * maxSamples , uint16_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32int32voidPtrint16voidPtruint16Thunk';fcns.name{fcnNum}='ps5000GetTimebase2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'int32', 'singlePtr', 'int16', 'int32Ptr', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetSigGenArbitrary ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , uint32_t startDeltaPhase , uint32_t stopDeltaPhase , uint32_t deltaPhaseIncrement , uint32_t dwellCount , int16_t * arbitraryWaveform , int32_t arbitraryWaveformSize , SWEEP_TYPE sweepType , int16_t whiteNoise , INDEX_MODE indexMode , uint32_t shots , uint32_t sweeps , SIGGEN_TRIG_TYPE triggerType , SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16int32uint32uint32uint32uint32uint32voidPtrint32SWEEP_TYPEint16INDEX_MODEuint32uint32SIGGEN_TRIG_TYPESIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps5000SetSigGenArbitrary'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'uint32', 'uint32', 'uint32', 'uint32', 'int16Ptr', 'int32', 'enSweepType', 'int16', 'enIndexMode', 'uint32', 'uint32', 'enSigGenTrigType', 'enSigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetSigGenBuiltIn ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , int16_t waveType , float startFrequency , float stopFrequency , float increment , float dwellTime , SWEEP_TYPE sweepType , int16_t whiteNoise , uint32_t shots , uint32_t sweeps , SIGGEN_TRIG_TYPE triggerType , SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16int32uint32int16floatfloatfloatfloatSWEEP_TYPEint16uint32uint32SIGGEN_TRIG_TYPESIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps5000SetSigGenBuiltIn'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'int16', 'single', 'single', 'single', 'single', 'enSweepType', 'int16', 'uint32', 'uint32', 'enSigGenTrigType', 'enSigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetSigGenBuiltInV2 ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , int16_t waveType , double startFrequency , double stopFrequency , double increment , double dwellTime , SWEEP_TYPE sweepType , int16_t whiteNoise , uint32_t shots , uint32_t sweeps , SIGGEN_TRIG_TYPE triggerType , SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16int32uint32int16doubledoubledoubledoubleSWEEP_TYPEint16uint32uint32SIGGEN_TRIG_TYPESIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps5000SetSigGenBuiltInV2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'int16', 'double', 'double', 'double', 'double', 'enSweepType', 'int16', 'uint32', 'uint32', 'enSigGenTrigType', 'enSigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SigGenSoftwareControl ( int16_t handle , int16_t state ); 
fcns.thunkname{fcnNum}='uint32int16int16Thunk';fcns.name{fcnNum}='ps5000SigGenSoftwareControl'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetEts ( int16_t handle , PS5000_ETS_MODE mode , int16_t etsCycles , int16_t etsInterleave , int32_t * sampleTimePicoseconds ); 
fcns.thunkname{fcnNum}='uint32int16PS5000_ETS_MODEint16int16voidPtrThunk';fcns.name{fcnNum}='ps5000SetEts'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS5000EtsMode', 'int16', 'int16', 'int32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetTriggerChannelProperties ( int16_t handle , TRIGGER_CHANNEL_PROPERTIES * channelProperties , int16_t nChannelProperties , int16_t auxOutputEnable , int32_t autoTriggerMilliseconds ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16int16int32Thunk';fcns.name{fcnNum}='ps5000SetTriggerChannelProperties'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tTriggerChannelPropertiesPtr', 'int16', 'int16', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetTriggerChannelConditions ( int16_t handle , TRIGGER_CONDITIONS * conditions , int16_t nConditions ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16Thunk';fcns.name{fcnNum}='ps5000SetTriggerChannelConditions'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tTriggerConditionsPtr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetTriggerChannelDirections ( int16_t handle , THRESHOLD_DIRECTION channelA , THRESHOLD_DIRECTION channelB , THRESHOLD_DIRECTION channelC , THRESHOLD_DIRECTION channelD , THRESHOLD_DIRECTION ext , THRESHOLD_DIRECTION aux ); 
fcns.thunkname{fcnNum}='uint32int16THRESHOLD_DIRECTIONTHRESHOLD_DIRECTIONTHRESHOLD_DIRECTIONTHRESHOLD_DIRECTIONTHRESHOLD_DIRECTIONTHRESHOLD_DIRECTIONThunk';fcns.name{fcnNum}='ps5000SetTriggerChannelDirections'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enThresholdDirection', 'enThresholdDirection', 'enThresholdDirection', 'enThresholdDirection', 'enThresholdDirection', 'enThresholdDirection'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetSimpleTrigger ( int16_t handle , int16_t enable , PS5000_CHANNEL source , int16_t threshold , THRESHOLD_DIRECTION direction , uint32_t delay , int16_t autoTrigger_ms ); 
fcns.thunkname{fcnNum}='uint32int16int16PS5000_CHANNELint16THRESHOLD_DIRECTIONuint32int16Thunk';fcns.name{fcnNum}='ps5000SetSimpleTrigger'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16', 'enPS5000Channel', 'int16', 'enThresholdDirection', 'uint32', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetTriggerDelay ( int16_t handle , uint32_t delay ); 
fcns.thunkname{fcnNum}='uint32int16uint32Thunk';fcns.name{fcnNum}='ps5000SetTriggerDelay'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetPulseWidthQualifier ( int16_t handle , PWQ_CONDITIONS * conditions , int16_t nConditions , THRESHOLD_DIRECTION direction , uint32_t lower , uint32_t upper , PULSE_WIDTH_TYPE type ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16THRESHOLD_DIRECTIONuint32uint32PULSE_WIDTH_TYPEThunk';fcns.name{fcnNum}='ps5000SetPulseWidthQualifier'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPwqConditionsPtr', 'int16', 'enThresholdDirection', 'uint32', 'uint32', 'enPulseWidthType'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000IsTriggerOrPulseWidthQualifierEnabled ( int16_t handle , int16_t * triggerEnabled , int16_t * pulseWidthQualifierEnabled ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps5000IsTriggerOrPulseWidthQualifierEnabled'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetTriggerTimeOffset ( int16_t handle , uint32_t * timeUpper , uint32_t * timeLower , PS5000_TIME_UNITS * timeUnits , uint16_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtruint16Thunk';fcns.name{fcnNum}='ps5000GetTriggerTimeOffset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'enPS5000TimeUnitsPtr', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetTriggerTimeOffset64 ( int16_t handle , int64_t * time , PS5000_TIME_UNITS * timeUnits , uint16_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtruint16Thunk';fcns.name{fcnNum}='ps5000GetTriggerTimeOffset64'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'longPtr', 'enPS5000TimeUnitsPtr', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetValuesTriggerTimeOffsetBulk ( int16_t handle , uint32_t * timesUpper , uint32_t * timesLower , uint32_t * timeUnits , uint16_t fromSegmentIndex , uint16_t toSegmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtruint16uint16Thunk';fcns.name{fcnNum}='ps5000GetValuesTriggerTimeOffsetBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'uint32Ptr', 'uint16', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetValuesTriggerTimeOffsetBulk64 ( int16_t handle , int64_t * times , uint32_t * timeUnits , uint16_t fromSegmentIndex , uint16_t toSegmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtruint16uint16Thunk';fcns.name{fcnNum}='ps5000GetValuesTriggerTimeOffsetBulk64'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'longPtr', 'uint32Ptr', 'uint16', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetDataBuffers ( int16_t handle , PS5000_CHANNEL channel , int16_t * bufferMax , int16_t * bufferMin , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16PS5000_CHANNELvoidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='ps5000SetDataBuffers'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS5000Channel', 'int16Ptr', 'int16Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetDataBuffer ( int16_t handle , PS5000_CHANNEL channel , int16_t * buffer , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16PS5000_CHANNELvoidPtrint32Thunk';fcns.name{fcnNum}='ps5000SetDataBuffer'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS5000Channel', 'int16Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetDataBufferBulk ( int16_t handle , PS5000_CHANNEL channel , int16_t * buffer , int32_t bufferLth , uint16_t waveform ); 
fcns.thunkname{fcnNum}='uint32int16PS5000_CHANNELvoidPtrint32uint16Thunk';fcns.name{fcnNum}='ps5000SetDataBufferBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS5000Channel', 'int16Ptr', 'int32', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetEtsTimeBuffer ( int16_t handle , int64_t * buffer , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint32Thunk';fcns.name{fcnNum}='ps5000SetEtsTimeBuffer'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'longPtr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetEtsTimeBuffers ( int16_t handle , uint32_t * timeUpper , uint32_t * timeLower , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='ps5000SetEtsTimeBuffers'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000IsReady ( int16_t handle , int16_t * ready ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps5000IsReady'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000RunBlock ( int16_t handle , int32_t noOfPreTriggerSamples , int32_t noOfPostTriggerSamples , uint32_t timebase , int16_t oversample , int32_t * timeIndisposedMs , uint16_t segmentIndex , void * lpReady , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16int32int32uint32int16voidPtruint16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps5000RunBlock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'int32', 'uint32', 'int16', 'int32Ptr', 'uint16', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000RunStreaming ( int16_t handle , uint32_t * sampleInterval , PS5000_TIME_UNITS sampleIntervalTimeUnits , uint32_t maxPreTriggerSamples , uint32_t maxPostPreTriggerSamples , int16_t autoStop , uint32_t downSampleRatio , uint32_t overviewBufferSize ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrPS5000_TIME_UNITSuint32uint32int16uint32uint32Thunk';fcns.name{fcnNum}='ps5000RunStreaming'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'enPS5000TimeUnits', 'uint32', 'uint32', 'int16', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetStreamingLatestValues ( int16_t handle , void * lpPs5000Ready , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps5000GetStreamingLatestValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000NoOfStreamingValues ( int16_t handle , uint32_t * noOfValues ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps5000NoOfStreamingValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetMaxDownSampleRatio ( int16_t handle , uint32_t noOfUnaggreatedSamples , uint32_t * maxDownSampleRatio , int16_t downSampleRatioMode , uint16_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtrint16uint16Thunk';fcns.name{fcnNum}='ps5000GetMaxDownSampleRatio'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'int16', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetValues ( int16_t handle , uint32_t startIndex , uint32_t * noOfSamples , uint32_t downSampleRatio , int16_t downSampleRatioMode , uint16_t segmentIndex , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtruint32int16uint16voidPtrThunk';fcns.name{fcnNum}='ps5000GetValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'uint32', 'int16', 'uint16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetValuesBulk ( int16_t handle , uint32_t * noOfSamples , uint16_t fromSegmentIndex , uint16_t toSegmentIndex , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16voidPtruint16uint16voidPtrThunk';fcns.name{fcnNum}='ps5000GetValuesBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint16', 'uint16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000GetValuesAsync ( int16_t handle , uint32_t startIndex , uint32_t noOfSamples , uint32_t downSampleRatio , int16_t downSampleRatioMode , uint16_t segmentIndex , void * lpDataReady , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16uint32uint32uint32int16uint16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps5000GetValuesAsync'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32', 'uint32', 'int16', 'uint16', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000Stop ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps5000Stop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000PingUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps5000PingUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps5000SetNoOfCaptures ( int16_t handle , uint16_t nCaptures ); 
fcns.thunkname{fcnNum}='uint32int16uint16Thunk';fcns.name{fcnNum}='ps5000SetNoOfCaptures'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16'};fcnNum=fcnNum+1;
structs.tTriggerConditions.packing=1;
structs.tTriggerConditions.members=struct('channelA', 'enTriggerState', 'channelB', 'enTriggerState', 'channelC', 'enTriggerState', 'channelD', 'enTriggerState', 'external', 'enTriggerState', 'aux', 'enTriggerState', 'pulseWidthQualifier', 'enTriggerState');
structs.tPwqConditions.packing=1;
structs.tPwqConditions.members=struct('channelA', 'enTriggerState', 'channelB', 'enTriggerState', 'channelC', 'enTriggerState', 'channelD', 'enTriggerState', 'external', 'enTriggerState', 'aux', 'enTriggerState');
structs.tTriggerChannelProperties.packing=1;
structs.tTriggerChannelProperties.members=struct('thresholdMajor', 'int16', 'thresholdMinor', 'int16', 'hysteresis', 'uint16', 'channel', 'enPS5000Channel', 'thresholdMode', 'enThresholdMode');
enuminfo.enChannelBufferIndex=struct('PS5000_CHANNEL_A_MAX',0,'PS5000_CHANNEL_A_MIN',1,'PS5000_CHANNEL_B_MAX',2,'PS5000_CHANNEL_B_MIN',3,'PS5000_CHANNEL_C_MAX',4,'PS5000_CHANNEL_C_MIN',5,'PS5000_CHANNEL_D_MAX',6,'PS5000_CHANNEL_D_MIN',7,'PS5000_MAX_CHANNEL_BUFFERS',8);
enuminfo.enPS5000Channel=struct('PS5000_CHANNEL_A',0,'PS5000_CHANNEL_B',1,'PS5000_CHANNEL_C',2,'PS5000_CHANNEL_D',3,'PS5000_EXTERNAL',4,'PS5000_MAX_CHANNELS',4,'PS5000_TRIGGER_AUX',5,'PS5000_MAX_TRIGGER_SOURCES',6);
enuminfo.enPS5000Range=struct('PS5000_10MV',0,'PS5000_20MV',1,'PS5000_50MV',2,'PS5000_100MV',3,'PS5000_200MV',4,'PS5000_500MV',5,'PS5000_1V',6,'PS5000_2V',7,'PS5000_5V',8,'PS5000_10V',9,'PS5000_20V',10,'PS5000_50V',11,'PS5000_MAX_RANGES',12);
enuminfo.enIndexMode=struct('SINGLE',0,'DUAL',1,'QUAD',2,'MAX_INDEX_MODES',3);
enuminfo.enSweepType=struct('UP',0,'DOWN',1,'UPDOWN',2,'DOWNUP',3,'MAX_SWEEP_TYPES',4);
enuminfo.enSigGenTrigType=struct('SIGGEN_RISING',0,'SIGGEN_FALLING',1,'SIGGEN_GATE_HIGH',2,'SIGGEN_GATE_LOW',3);
enuminfo.enThresholdDirection=struct('ABOVE',0,'BELOW',1,'RISING',2,'FALLING',3,'RISING_OR_FALLING',4,'INSIDE',0,'OUTSIDE',1,'ENTER',2,'EXIT',3,'ENTER_OR_EXIT',4,'NONE',2);
enuminfo.enPS5000ChannelInfo=struct('CI_RANGES',0);
enuminfo.enWaveType=struct('PS5000_SINE',0,'PS5000_SQUARE',1,'PS5000_TRIANGLE',2,'PS5000_RAMP_UP',3,'PS5000_RAMP_DOWN',4,'PS5000_SINC',5,'PS5000_GAUSSIAN',6,'PS5000_HALF_SINE',7,'PS5000_DC_VOLTAGE',8,'PS5000_WHITE_NOISE',9,'MAX_WAVE_TYPES',10);
enuminfo.enSigGenTrigSource=struct('SIGGEN_NONE',0,'SIGGEN_SCOPE_TRIG',1,'SIGGEN_AUX_IN',2,'SIGGEN_EXT_IN',3,'SIGGEN_SOFT_TRIG',4);
enuminfo.enThresholdMode=struct('LEVEL',0,'WINDOW',1);
enuminfo.enPS5000TimeUnits=struct('PS5000_FS',0,'PS5000_PS',1,'PS5000_NS',2,'PS5000_US',3,'PS5000_MS',4,'PS5000_S',5,'PS5000_MAX_TIME_UNITS',6);
enuminfo.enTriggerState=struct('CONDITION_DONT_CARE',0,'CONDITION_TRUE',1,'CONDITION_FALSE',2,'CONDITION_MAX',3);
enuminfo.enPS5000EtsMode=struct('PS5000_ETS_OFF',0,'PS5000_ETS_FAST',1,'PS5000_ETS_SLOW',2,'PS5000_ETS_MODES_MAX',3);
enuminfo.enPulseWidthType=struct('PW_TYPE_NONE',0,'PW_TYPE_LESS_THAN',1,'PW_TYPE_GREATER_THAN',2,'PW_TYPE_IN_RANGE',3,'PW_TYPE_OUT_OF_RANGE',4);
enuminfo.enRatioMode=struct('RATIO_MODE_NONE',0,'RATIO_MODE_AGGREGATE',1,'RATIO_MODE_DECIMATE',2,'RATIO_MODE_AVERAGE',4,'RATIO_MODE_DISTRIBUTION',8);
methodinfo=fcns;